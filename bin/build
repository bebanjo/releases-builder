#!/usr/bin/env ruby

require 'date'
require 'yaml'
require 'open-uri'
require 'base64'

require 'rubygems'
require 'bundler'
Bundler.require(:build)
Dotenv.load

def parse_date(str)
  begin
    DateTime.parse(str).strftime('%Y-%m-%d')
  rescue
    raise 'Invalid date'
  end
end

def get_title(body)
  begin
    frontmatter = YAML.load(body)
    title       = frontmatter['title']
    title
  rescue
    raise 'Invalid frontmatter'
  end
end

def get_slug(body)
  begin
    frontmatter = YAML.load(body)
    slug        = frontmatter['title'].to_slug.normalize.to_s
    slug
  rescue
    raise 'Invalid frontmatter'
  end
end

def get_filename(body)
  begin
    frontmatter = YAML.load(body)
    title       = frontmatter['title'].to_slug.normalize.to_s
    date        = parse_date(frontmatter['date'].to_s)
    filename    = "#{date}-#{title}"
    filename
  rescue
    raise 'Invalid frontmatter'
  end
end

def prepare_content(body)
  content = Hash.new
  name = get_filename(body)
  updated_body = body

  regex = /[\"|\(](https:\/\/cloud.githubusercontent.com\/.*)[\"|\)]/
  attachments = body.scan(regex).uniq

  attachments.each_with_index do |attachment, i|
    extension = attachment[0].split('.').last
    file = open(attachment[0]) { |f| f.read }
    blob = Base64.encode64(file)
    index = "%02d" % (i + 1)
    filename = "media/#{name}-#{index}.#{extension}"
    content[filename] = blob
    updated_body.gsub!(attachment[0], "../#{filename}")
  end
  
  content["_posts/#{name}.md"] = Base64.encode64(updated_body)
  content
end

# https://github.com/jollygoodcode/jollygoodcode.github.io/issues/14
def commit(client, repo, ref, branch, message, content)
  begin
    base_branch = client.refs(repo).find do |reference|
      "refs/heads/#{ref}" == reference.ref
    end
    
    base_branch_sha = base_branch.object.sha
    new_branch = client.create_ref(repo, "heads/#{branch}", base_branch_sha)
    
    new_tree = content.map do |path, new_content|
      Hash(
        path: path,
        mode: '100644',
        type: 'blob',
        sha: client.create_blob(repo, new_content, 'base64')
      )
    end
    
    commit = client.git_commit(repo, new_branch['object']['sha'])
    tree = commit['tree']
    new_tree = client.create_tree(repo, new_tree, base_tree: tree['sha'])
    new_commit = client.create_commit(repo, message, new_tree['sha'], commit['sha'])
    
    client.update_ref(repo, "heads/#{branch}", new_commit['sha'])
  rescue
    raise 'Commit failed'
  end
end

def pr(client, repo, ref, branch, title, body)
  begin
    client.create_pull_request(repo, ref, branch, title, body)
  rescue
    raise 'PR failed'
  end
end

token = ENV['TOKEN']
repo  = ENV['REPO']
ref   = ENV['REF']
label = ENV['LABEL']

client = Octokit::Client.new(:access_token => token)
Octokit.auto_paginate = true

issues = client.list_issues(repo)
releases = issues.map do |issue|
  issue if issue[:body].to_s.split("\n").first.include?('---')
end.compact

if releases.size > 0
  releases.each do |release|
    labels = client.labels_for_issue(repo, release[:number])

    ready = false
    if labels.size > 0
      labels.each do |l|
        if l['name'].include?(label)
          ready = true 
        end
      end
    end
    
    if ready
      branch  = "#{release[:number]}-#{get_slug(release[:body])}"
      content = prepare_content(release[:body])
      commit(client, repo, ref, branch, "Implements ##{release[:number]}. This commit was autogenerated.", content)
      pr(client, repo, ref, branch, get_title(release[:body]), "Implements ##{release[:number]}. This PR was autogenerated.")
    end
  end
end